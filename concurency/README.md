# Experimental Concurrency

Tests if runnings independent COMMANDS in a mode that allows concurrency/overlaps is faster than running them serially.
We have tests for OpenMP and SYCL. 

# Install and Usage

## Requirement
- A OpenMP compiler (`omp_con`)
- A Sycl Compiler (`sycl_con`)
- `python3` with the `tabulate` package installed (optional, only if you want parse the .log file generated by the .sh scripts) 

## To run

On Intel hardware just use the `run_*.sh`. 

For other hardware, just edit the compilation stage (`icpx -std=c++17 -fsycl bench_sycl.cpp main.cpp -o sycl_con`)

## Usage (example of the sycl_con binary)
```
Usage: ./sycl_con (nowait | host_threads | serial)
                [--enable_profiling]
                [--tripcount_C <tripcount>]
                [--globalsize_{C,A2B} <global_size>]
                [--queues <n_queues>]
                [--repetitions <n_repetions>]
                COMMAND...

Options:
--tripcount_C               [default: -1]. Each kernel work-item will perform 64*C_tripcount FMA
                              '-1' will auto-tune this parameter so each commands take similar time
--globalsize_{C,A2B}        [default: -1]. Work-group size of the commands
                             '-1' will auto-tune this parameter so each commands take similar time
--globalsize_default_memory [default: -1].  Size of the memory buffer before auto-tuning
                             '-1' mean maximun possible size
--queues                    [default: -1]. Number of queues used to run COMMANDS
                              '-1' mean automatic selection:
                                - if `host_threads | in_order`, one threads/queues per COMMAND
                                - else one queue
--repetitions               [default: 10]. Number of repetions for each measuremnts
COMMAND                     [possible values: C, A2B]
                              C:  Compute kernel
                              A2B: Memcopy from A to B
                              Where A,B can be:
                                M: Malloc allocated memory
                                D: sycl::device allocated memory
                                H: sycl::host allocated memory
                                S: sycl::shared allocated memory
```

## OMP

With OpenMP one can hope to achieve concurrency using two main strategies 

### `host_threads`

```c++
#pragma omp parralel for
for () {
    #pragma omp target
    foo();
}
```

### `nowait`

```c++
for () {
    #pragma omp target nowait
    foo();
}
```

## SYCL

On SYCL  one can hope to achieve concurrency in two main fashions:

### One `out of order` queue

```c++
sycl::queue Q;
#pragma omp parralel for
for ()
    Q.submit(kernel);

Q.wait();
```

### Multiple `in order` queue

```c++
std::vector<sycl::queue> Qs
for ()
    Qs.push_back(sycl::queue(in_order));

for (auto Q: Qs)
    Q.submit();

for (auto Q: Qs)
    Q.wait();
```
